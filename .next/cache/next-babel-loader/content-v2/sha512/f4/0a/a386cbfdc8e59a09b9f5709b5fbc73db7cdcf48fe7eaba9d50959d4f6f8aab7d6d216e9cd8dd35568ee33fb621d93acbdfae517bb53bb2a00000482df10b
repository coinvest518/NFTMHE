{"ast":null,"code":"import { Fragment as _Fragment } from \"react/jsx-runtime\";\nimport { jsxs as _jsxs } from \"react/jsx-runtime\";\nimport { jsx as _jsx } from \"react/jsx-runtime\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport React, { useState, useEffect } from 'react';\nimport Head from 'next/head';\nimport AlphaBanner from 'components/base/AlphaBanner';\nimport MainHeader from 'components/base/MainHeader';\nimport TernoaWallet from 'components/base/TernoaWallet';\nimport Create from 'components/pages/Create';\nimport ModalMint from 'components/pages/Create/ModalMint';\nimport NotAvailableModal from 'components/base/NotAvailable';\nimport cookies from 'next-cookies';\nimport Router from 'next/router';\nimport { getUser } from 'actions/user';\nimport { imgToBlur, imgToWatermark } from 'utils/imageProcessing/image';\n\nconst CreatePage = ({\n  user\n}) => {\n  const {\n    0: modalExpand,\n    1: setModalExpand\n  } = useState(false);\n  const {\n    0: notAvailable,\n    1: setNotAvailable\n  } = useState(false);\n  const {\n    0: modalCreate,\n    1: setModalCreate\n  } = useState(false);\n  const {\n    0: select,\n    1: setSelect\n  } = useState('Select NFT Option');\n  const {\n    0: processed,\n    1: setProcessed\n  } = useState(false);\n  const {\n    0: error,\n    1: setError\n  } = useState('');\n  const {\n    0: output,\n    1: setOutput\n  } = useState([]);\n  const isNftCreationEnabled = process.env.NEXT_PUBLIC_IS_NFT_CREATION_ENABLED === undefined ? true : process.env.NEXT_PUBLIC_IS_NFT_CREATION_ENABLED === 'true';\n  const [NFTData, setNFTData] = React.useState({\n    name: '',\n    description: '',\n    quantity: 1\n  });\n  const {\n    0: walletUser,\n    1: setWalletUser\n  } = useState(user);\n  useEffect(() => {\n    async function callBack() {\n      try {\n        let res = await getUser(window.walletId);\n        setWalletUser(res);\n      } catch (error) {\n        console.error(error);\n      }\n    }\n\n    if (window.isRNApp && window.walletId) callBack();\n  }, []);\n  useEffect(() => {\n    if (!isNftCreationEnabled) {\n      Router.push(\"/\");\n    }\n  }, [isNftCreationEnabled]);\n  const {\n    0: NFT,\n    1: setNFT\n  } = useState(null);\n  const {\n    0: secretNFT,\n    1: setSecretNFT\n  } = useState(null);\n  const {\n    name,\n    description,\n    quantity\n  } = NFTData;\n  const {\n    0: QRData,\n    1: setQRData\n  } = useState({\n    links: output,\n    walletId: user ? user.walletId : '',\n    fileHash: '',\n    price: 1\n  });\n  useEffect(() => {\n    if (processed) {\n      uploadNFT();\n    }\n  }, [processed]);\n\n  async function processFile() {\n    try {\n      if (!secretNFT) {\n        throw new Error();\n      }\n\n      setOutput([]);\n      setError('');\n\n      if (select === 'Blur' && secretNFT.type.substr(0, 5) === 'image') {\n        const processFile = new File([secretNFT], 'NFT', {\n          type: secretNFT.type\n        });\n        let res = await imgToBlur(processFile);\n        const blob = await (await fetch(res)).blob();\n        const file = new File([blob], secretNFT.name, {\n          type: secretNFT.type\n        });\n        setNFT(file);\n        setProcessed(true);\n      } else if (select === 'Protect' && secretNFT.type.substr(0, 5) === 'image') {\n        const processFile = new File([secretNFT], 'NFT', {\n          type: secretNFT.type\n        });\n        let res = await imgToWatermark(processFile);\n        const blob = await (await fetch(res)).blob();\n        const file = new File([blob], secretNFT.name, {\n          type: secretNFT.type\n        });\n        setNFT(file);\n        setProcessed(true);\n      }\n    } catch (err) {\n      setError('Please try again.');\n      console.log(err);\n    }\n  }\n\n  async function uploadNFT() {\n    try {\n      if (!user) {\n        setError('Please login to create an NFT.');\n      }\n\n      if (!secretNFT || !name || !description || !NFT && !(select === 'Select NFT Option' || select === 'None')) {\n        throw new Error('Elements are undefined');\n      }\n\n      const data = new FormData();\n      {\n        NFT ? data.append('file', NFT) : data.append('file', secretNFT);\n      }\n      const resUpload = await fetch(`${process.env.NEXT_PUBLIC_SDK_URL}/api/uploadIM`, {\n        method: 'POST',\n        body: data\n      });\n      const {\n        url: previewLink,\n        mediaType\n      } = await resUpload.json();\n      let cryptPromises = [];\n\n      for (let i = 0; i < quantity; i++) {\n        const formData = new FormData();\n        formData.append('file', secretNFT);\n        cryptPromises.push(fetch(`${process.env.NEXT_PUBLIC_SDK_URL}/api/cryptFile`, {\n          method: 'POST',\n          body: formData\n        }));\n      }\n\n      try {\n        const cryptResults = await Promise.all(cryptPromises);\n        const cryptJSONs = await Promise.all(cryptResults.map(r => r.json()));\n        const results = cryptJSONs.map((result, index) => {\n          return fetch(`${process.env.NEXT_PUBLIC_SDK_URL}/api/uploadEx`, {\n            method: 'POST',\n            body: new URLSearchParams({\n              name,\n              description,\n              fileHash: result.fileHash,\n              keyPath: result.keyPath,\n              media: previewLink,\n              mediaType,\n              cryptedMedia: result.file,\n              cryptedMediaType: secretNFT.type,\n              itemTotal: quantity + '',\n              itemId: index + 1 + ''\n            })\n          });\n        });\n        const JSONPromises = await Promise.all(results);\n        const JSONURLS = await Promise.all(JSONPromises.map(r => r.json()));\n        setOutput(JSONURLS);\n        setQRData(_objectSpread(_objectSpread({}, QRData), {}, {\n          links: JSONURLS,\n          fileHash: cryptJSONs[0].fileHash\n        }));\n        setProcessed(false);\n      } catch (err) {\n        console.error(err);\n      }\n\n      return output;\n    } catch (err) {\n      setError('Please try again.');\n      console.log(err);\n      return [];\n    }\n  }\n\n  return /*#__PURE__*/_jsxs(_Fragment, {\n    children: [/*#__PURE__*/_jsxs(Head, {\n      children: [/*#__PURE__*/_jsx(\"title\", {\n        children: \"SecretNFT - Create your NFT\"\n      }), /*#__PURE__*/_jsx(\"meta\", {\n        name: \"viewport\",\n        content: \"initial-scale=1.0, width=device-width\"\n      }), /*#__PURE__*/_jsx(\"meta\", {\n        name: \"description\",\n        content: \"SecretNFT Marketplace, by Ternoa.\"\n      }), /*#__PURE__*/_jsx(\"meta\", {\n        name: \"og:image\",\n        content: \"ternoa-social-banner.jpg\"\n      })]\n    }), modalExpand && /*#__PURE__*/_jsx(TernoaWallet, {\n      setModalExpand: setModalExpand\n    }), notAvailable && /*#__PURE__*/_jsx(NotAvailableModal, {\n      setNotAvailable: setNotAvailable\n    }), modalCreate && /*#__PURE__*/_jsx(ModalMint, {\n      setModalCreate: setModalCreate,\n      processed: processed,\n      error: error,\n      setError: setError,\n      output: output,\n      QRData: QRData\n    }), /*#__PURE__*/_jsx(AlphaBanner, {}), /*#__PURE__*/_jsx(MainHeader, {\n      user: walletUser,\n      setModalExpand: setModalExpand\n    }), isNftCreationEnabled && /*#__PURE__*/_jsx(Create, {\n      setModalExpand: setModalExpand,\n      setNotAvailable: setNotAvailable,\n      setModalCreate: setModalCreate,\n      user: walletUser,\n      NFT: NFT,\n      setNFT: setNFT,\n      secretNFT: secretNFT,\n      setSecretNFT: setSecretNFT,\n      NFTData: NFTData,\n      setNFTData: setNFTData,\n      select: select,\n      setSelect: setSelect,\n      processFile: processFile,\n      setError: setError,\n      setProcessed: setProcessed\n    })]\n  });\n};\n\nexport async function getServerSideProps(ctx) {\n  let user = null;\n  const token = cookies(ctx).token;\n  if (token) user = await getUser(token).catch(() => null);\n  return {\n    props: {\n      user\n    }\n  };\n}\nexport default CreatePage;","map":null,"metadata":{},"sourceType":"module"}